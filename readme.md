##[0]这是一个参照json-tutorial这个项目完成的json parser/generator。json_tutorial01是我自己的实现,其余文件为原始项目。
##[1]使用C++。
##[2]参照了boost::property_tree设计了部分读写API。
##[3]大部分内容属于自己独立完成,包括parse部分的一些算法设计。与原始的项目有较大不同。
##[4]具体实现已经遇到的坑放在博客详细说明。
##[5]由于项目经验很少,所以本次设计从架构上来说有不少缺陷,多弄了一个json_value和json_tree的连接层,
###尽管增加了一定的抽象程度,但是似乎没有必要?这也是一个教训。

# 我的json parser/generator
-------------------

**json parser**是用来解析json的工具,按照规则将符合标准json文本转换成相应的数据结构(类)。


- **使用语言** ： C++(11)。
- **项目规模** ：实现部分700行左右,测试部分400行左右。
- **耗时**：大约一周。
## **功能简介:**
### [1] 解析器部分:
能解析**NULL,False,True,Number**(只支持**double**),**String,array,object**六种类型。对于常见的出现错误定义了相应的错误码。
### [2] 生成器部分:
能够将解析好的数据再转换成为json格式的文本。能够对现有的数据进行修改,实现了添加,修改两部分的功能。对于删除部分尚未实现(**to do**)。
### [3] 测试部分:
对所有类型的解析/生成均做了相应的测试。
对重要API做了相应测试。



>由于篇幅和精力所限制,我只选择阐述部分较为重要的实现,具体细节可以看源码。

### [1]整体框架
 我们创建一个叫做json_value的类来存储不同的类型和值,创建json_tree这个类用来解析相应json文本并保存在json_value里面。
#### (1)json_value可能代表6个类型中的一种
 (null,false,true,number,string,array,object)

 为了节约空间,我们选择使用一个union将这六种类型的变量全部封装起来,但是由于string,vector,map等类型不是简单类型,所以我们必须自己创建相应的**构造函数,拷贝构造函数,赋值运算符,析构函数**来保证相应的操作的正确执行。
同时我们不直接使		用**vector<json_value>,map<string,json_value>**来代表array和object,而是将里面的元素替换成为相应的智能指针,这样节约空间并且不用担心内存泄漏。

#### (2)json_tree执行具体的解析
 json_tree留给外部使用的接口是**lept_parse(const string&)**

这个函数负责最外层的判断以及部分处理错误的功能,我们首先写好**lept_parse_whitespace()**这个函数用来去掉分割用的空格。然后将剩下的工作交给另一个函数**lpet_parse_value**：检测遇到的第一个字符,根据

```
(n,f,t,",[,{,其他(数字或者无效值))
```
这六种首字母的情况,我们可以很容易的确定需要解析的是哪一种。这里我们分别实现对应功能的函数。

### [2] Literal(null,false,true):
 literal是指普通的字面值类型,一共三种 null,false,true

由于这三种类型非常相似,所以我选择一个函数**lept_parse_literal**来解析这三种类型,在这个函数里面,我们只需要判断它是三种类型里面的哪一种,并且指定好相应的类型即可。
此外,还需要处理可能发生的错误,比如nul,fuck这种无效的字符。这一块的难度不大,细心即可顺利的完成。
**注意**,我们还要处理类似 "null x"这样的不正确输入,并且返回的错误类型应该是NOT_SINGULAR_ROOT(该节点不止一个值)。

### [3] Number的解析
 也许这是整个项目最困难的部分,但是我选择一定程度的回避^_^

####[1]首先我们了解number的格式以及错误输入:
**(1)**json的number不支持**+xxx**的形式,只支持**-xxxx/xxxx**,所以首先要处理这一块可能的错误格式。
**(2)**其次不支持**0xxx**的格式,只支持**0.xxxx**，所以0123是错误的输入。
**(3)**对于小数点后面的位数,至少要有一位数字。所以
**1.**,**0.**这样都是不正确的。
**(4)**支持**xxxxE(e)+yyyy,xxxxE(e)-yyyy**这样的格式,所以**1.234E+12**是正确的输入。
**(5)**还可能出现超过**0-9**范围之外的字符,这同样是不正确的输入。
####[2]解析:
如果手动来序列话浮点数其实解决方案会相当的麻烦,由于只是一个用来练习的项目,所以我选择使用stod这个函数来进行转换。注意,这里有一个**坑^[[1]]**:
>如果我们选择strtod这个函数会发现它不能很好的进行边界值的判断,比如**1E-1000**其实是应该解析为**0**，但是这里会被认为指数太大而越界。而stod这个函数则会对超过浮点数最值的文本都转换为一个HUGE_VAL|-HUGE_VAL,这样我们就能精确的判定是不是范围越界了。然而stod接受的参数是char*,所以这里要来回转换会使得实现起来比较不舒服。

我们首先需要判断前面提到的可能的错误,因为stod函数并不会帮我们进行判断,它只会在第一个不满足格式的字符前停止解析,同时它支持的一些格式json不支持。所以必须要手动判断。

判断完成之后我们需要确认当前的字符,如果是

    , [ { 空格 \t \f \r \s \n
我们可以暂时不报错,因为这些可能是分割符号,至于这些符号是否满足正确的格式,交给调用lept_parse_number的外层函数来判断。如果是其他字符,那么可以判定当前的解析数字不成功,返回相应的错误。

最后我们还要处理可能的越界错误。
>这一部分的解析相当麻烦,虽然代码量看似不大,但是要考虑的问题较多,一不小心就会出错,我在这个地方花费来一下午才通过所有测试。

###[4] string的解析:
 这一部分的解析包含两个内容,第一个是普通的字符和转义字符,第二个是unicode的转义字符。

####[1]普通\转义 字符的解析:
 首先认识到string里面的所有需要转义的字符都应该多加一个\来表示,因为json文本本身是被包含在一对双引号之内的。

对于普通的字符,没有什么好说的,只需要直接翻译就好了,但是注意对于**ASCII码在1-31之间**的普通字符是非法的。

对于转义字符,我们一共有如下这些可能:

    \n \b \f\ \r \t \" \\ \/ \u 
在switch语句里面,针对每一种类型,我们都需要翻译成真正的转义字符,这里相当于做了一个简化版本的C语言对字面值的parse工作。由于这些工作的相似度（除了\u）很高,所以我们可以用一个宏来完成这些类似的工作,注意宏后面记得加上break,我在这里浪费了不少时间检查。

####[2] unicode字符的解析:
 这一部分比上面要困难一些,主要在于需要真正搞清楚unicode和utf-8之间的转换关系,以及可能遇见的错误格式。

#####[1] 码点和代理对
面对unicode字符,我们需要将它转换成utf-8的格式,unicode采用一个整数码点来映射到字符集。
首先假设输入合法:
面对一个**\uxxxx**,它表示**U+0000**到**U+FFFF**，我们需要将这个十六进制解析成为一个整数码点。同时由于字符串是通过UTF-8来存储的,所以我们也要把这个码点编码成**UTF-8**.

但是注意到这个十六进制的数是不能表示完所有的码点的。其实Json字符对于超过U+FFFF范围以外的码点,选择采用代码对来表示,如果第一个码点是U+DC00到U+DBFF,那么我们就知道它应该和后面紧跟的另外一个码点共同代表一个码点。具体的转换就不仔细说了。

#####[2] UTF-8编码
 而UTF-8是一种存储码点的格式,它选择将码点存储为一到多个存储单元,其中每一个单元是一个字节,所以每个ASCII字符只需要一个字节去存储。我们的json parser只支持UTF-8的格式。
得到来真正的码点(整数),我们就需要把它按照UTF-8的格式来存储,UTF-8把二进制的码点拆分为1-4个字节。这个编码方式和ASCII码编码是兼容的,而这个范围内的unicode字符和ASCII字符相同。

具体的编码方式也不仔细说了,总之我们要按照码点的大小来进行拆分,涉及到一些位运算。

#####[3] 总结
所以整个过程分成两个步骤,第一是将json里面的unicode转义字符变成码点,然后是将码点拆分成1到4个字节。
这一部分的内容同样不简单,涉及到字符到整数的转换(包含无效字符等不正确格式的处理),整数之间的位运算等内容。当然由于规则比较明显,只要按照标准一步一步的走下去,没有什么太大的难度。

###[5]数组的解析
 数组是一个复合结构,很明显这里必须将数据结构涉及为树状的。我们选择`vector<shared_ptr  <json_value > >`来表示一个数组。 
 数组实例: `[1,[2,3,[4,"567"]，false,true],null]`
####[1] 错误处理
首先在解析数组的时候有这样几种可能的错误
(1)数组本省某个元素解析错误
(2)数组缺少 逗号(,)
(3)数组缺少 **]**
(4)特殊情况 空数组
这几种错误相对来说不难处理,当然需要注意调用**lept_parse_whitespace()**来去掉中间用来分割的空白字符。
>考虑一下有两个,,的时候会发生什么? `~^_^~`

####[2]递归解析的过程
这一部分也比较简单,我们对于任意一个元素,只要调用**lept_parse_value()**这个函数就可以了,它会帮我们解析元素的成分,当它解析成功之后,我们只需要将新的`shared_ptr<json_value>`添加到vector里面就可以了。

###[6]object的解析
 object就是对象,它由{key:value}来表示,同样是一个符合结构,不过它比数组要复杂一点.
####[1]可能的错误:
 有如下几种可能的错误:

(1)缺少 :
(2)缺少 ,
(3) 缺少 }
(4)key或者value的解析不正确.
(5)特殊情况 空对象

这几种错误同样算不上很麻烦,但是实现起来还是需要细心,我们需要把逻辑理清楚,一点一点的判断即可.

####[2]递归的过程
 由于json没有规定只能有一个key,所以我们必须选择**multimap**,同时考虑到查找的效率,**unordered_multimap**应该是比较好的选择.

同样我们只需要把key先解析出来,然后解析掉可能的空格以及分割符,最后调用**lept_parse_value()**来解析value即可.最后把**`{key,shared_ptr<json_value>}`**插入到**unordered_multimap**里面即可.




